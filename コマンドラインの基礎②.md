## 🔰 はじめに

こんにちは。前回に引き続き、Linuxの学習記録です！  
今回は**ファイル操作の後編**ということで、**パーミッション・ユーザー管理・リンクファイルなど**について学んだことをまとめました。

使用する環境は引き続き **Ubuntu（Debian系）** です。  
→ 前回記事を見ていない方は、[こちらからどうぞ！](https://qiita.com/Nishi_Ta/items/8be690a74cc9b2c6de82)

---

## 📁 今回の学習範囲

以下の内容について触れています：

- ファイルとディレクトリの**権限（パーミッション）**
- 所有者・グループの変更
- シンボリックリンク・ハードリンク
- `find` や `grep` の使い方
- パーミッションの変更（`chmod`）
- 所有者の変更（`chown`）
- 実行権限などの確認方法

---

## 📘 コマンドまとめ（今回扱ったもの）

| コマンド | 概要 |
|----------|------|
| `ls -l` | 所有権を確認する |
| `chmod` | パーミッションを変更する |
| `chown` | 所有者の変更 |
| `chgrp` | グループのみを変更する |
| `umask` | アクセス権限の引き算（マスク）をする |
| `ln` | リンクファイルを作成する（`-s`でシンボリックリンク） |
| `ps` | 現在動作しているプロセスを表示すること |
| `top` | プロセス、システムリソースの状態を更新して表示するコマンド |
| `job` | 現在処理中のジョブを表示する |
| `fg` | フォアグランドジョブに切り替える |
| `bg` | バックグラウンドジョブに切り替える |
| `nohup` | ターミナルが閉じられてもジョブを継続して実行するコマンド |
| `screen` | 1つのターミナル上で、複数のスクリーンによる操作を管理する |
| `kill` | 	シグナルを送るためのコマンド |


---

## 🔍 実際に使ってみた！

個人的に理解しずらかったコマンドの実行結果を実際に自分の手を動かしてアウトプットしてみました。<br></br><br></br>


<details>
<summary>▶️ コマンド使用例・結果まとめ</summary>


---


`chmod`コマンド実行結果：<br></br><br></br>


このコマンドを扱うにあたり、 **オクタルモード** （権限を8進数で表したもの）か **シンボルモード** （パーミッションを記号であらわしたもの）のどちらか一方でパーミッションを変更できます。今回はシンボルモードで変更したので、ご了承ください<br></br>


| コマンド | 概要 |
|----------|------|
| `u` | 所有者 |
| `g` | 所有ユーザー |
| `o` | その他のユーザー |
| `a` | すべての対処 |
| `+` | 追加 |
| `-` | 削除 |
| `=` | 設定 |
| `r` | 読み取り |
| `w` | 書き込み |
| `x` | 実行 |
| `s` | SUID/SGID |
| `t` | スティッキービット |

test2.txt にて、所有者と所有ユーザーの書き込み権限を削除してみました。赤線部と青線部を比較すると、確かに所有者の「w」が消えていることが分かります。



![chmodこまんど.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/12a301a7-52e4-49d5-a3fc-9f754faf8a66.png)








 
⚠ `chmod`コマンドでパーミッションを変更できるのは、ルートユーザー、もしくは、所有者のみになります。また、-Rオプションをつけることで、フォルダ内のファイル、サブディレクトリも併せてパーミッションを変更できます。


---

`chown`コマンド実行結果：<br></br><br></br>

まずはユーザーを追加するために、 `sudo useradd testuser` とコマンドを入力して、"testuser"を追加しました。<br></br>
`sudo`コマンドは、通常ユーザーではできない「システムの更新」を、一時的に管理者（root）として実行するものです。<br></br>

1枚目では `sudo chown testuser test1` コマンドを実行した結果、test1 ディレクトリの所有者がubuntuからtestuserに代わっていることが分かります。

2枚目では、-Rオプションをつけて、 test ディレクトリ内の所有者も testuserに変更しました。

![tetuser1.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/c71c5bb5-08ef-436d-b8d5-7a542539def4.png)



![testuser2.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/f6dce980-3872-44fc-bfa7-d3e6992eac9d.png)



⚠このコマンドも `chmod` コマンドと同様に、ルートユーザー、所有者のみ実行できます。



---

`chgrp`コマンド実行結果：<br></br><br></br>

先ほどと同じで順で、 "testgroup" という新しいグループを作成しました。<br></br>


1枚目では test1 ディレクトリの所有者を testgroup に変えてみました。赤線と青線を見比べてみると確かに確認できますね。<br></br>


2枚目では、オプションに -Rをつけて、ディレクトリ内のファイル、サブディレクトリもあわせて、パーミッションを変更してみました。



![tesstgrp.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/6aeca7c2-ed05-40b5-992a-9ff2ea8cbf13.png)



![testgrp.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/b604d635-f8c1-47d1-90ce-37d0756fae49.png)


---

`umask`コマンドの概要：<br></br><br></br>

このコマンドは実行する形式ではなく、概要をまとめる形にします。以下の流れは、マスク値を設定するものです。<br></br><br></br>


【ファイル、ディレクトリ作成の流れ】

【1】新規ファイル作成（ユーザが操作）

　　　↓


【2】デフォルトパーミッションが適用される

　ファイル： 666　→　rw-rw-rw-　（※実行権なし）
　フォルダ： 777　→　rwxrwxrwx　（※実行権あり）

　　　↓

【3】umask（例：0022）を適用する

　666 - 022 = 644　→　rw-r--r--
　777 - 022 = 755　→　rwxr-xr-x

　　　↓

【4】最終的なパーミッションが決まる<br></br><br></br>

つまり一言でまとめると、新しく作るファイルやディレクトリのパーミッションに、 **不要な権限が付かないよう自動で制限** する仕組みということです。<br></br>

---

`ln`コマンド実行結果：<br></br><br></br>

コマンド説明欄では、「リンクファイルを作成する」と書きましたが、そもそもLinuxにおけるリンクファイルとはなんなのでしょうか。<br></br>

リンクとは、 **ファイルを指し示す“別名”や“案内板”** のようなものです。...私だったら説明されてもピンと来ません。なので、より理解を深めるために、まずは「iノード」という概念を知っておく必要があります。<br></br>

iノードは、 **ファイルの本体情報（データの位置や属性）を管理している領域 **です。例えば...<br></br>

- ファイルの中身（データの場所）
- 作成日時、更新日時
- 所有者
- パーミッション<br></br>

などです。iノードの概念が分かったら、次はリンクとiノードの関係性についてです。<br></br>

リンクを用いれば、iノードに対して複数の名前（パス）からアクセスできるようになります。すなわち、「このデータを、他の名前でも使いたい」というときに用いられます。これをレポートを例に挙げると次のようになります。<br></br>

【１】 `echo "レポート本文" > レポート.txt` コマンドを実行。<br></br>


→ レポート.txt というテキストファイルに "レポート本文" という文字列が保存された。

   
   
   
   ↓


【２】この時、Linux内では、<br></br>
「レポート.txt」 → iノード123 → 実際のデータ」という流れになっている。


　　　↓


【３】ここで別のテキストファイルの backup.txt で同じ中身を見たいなら、

`ln レポート.txt backup.txt`  コマンドを実行して、ハードリンクを作成。（ハードリンクは後々解説）


　　↓


【４】ハードリンクを作成したため、Linux内部では、<br></br>

「レポート.txt」 → iノード123 ← backup.txtとなり、両方とも 同じ iノード を指しているため、どちらのファイル名からもまったく同じ内容を見たり編集したりできる。<br></br><br></br>

これが最後の解説の内容になりますが、リンクには、「ハードリンク」と「シンボリックリンク」の二つがあります。<br></br>

ハードリンクは、先ほどレポートを例に挙げたように、 **「同じ本体を複数の名前で共有」** するものです。<br></br>

シンボリックリンクは、 **本体ファイルの「場所だけを覚えているショートカット」** というものです。身近なもので言い表すなら、windowsキーのショーとっかとのようなものです。<br></br>


【ハードリンクトシンボリックリンクの違い】

| 特徴          | ハードリンク    | シンボリックリンク        |
| ----------- | --------- | ---------------- |
|　リンク元とデータを共有する？    | ✅（iノード同じ） | ❌（iノード別）         |
| 元データが消えたら？     | 問題ない      | ❌ 壊れる（デッドリンク）    |
| 別のフォルダでもリンクできるか。 | ❌ できない    | ✅ できる            |
| 中身は？        | 実体と同じ     | 「参照先のパス」が書かれてるだけ |



メモ書きはこのあたりにして、次は実際に `ln`コマンドを実行します。<br></br><br></br>

1枚目は、 hard.ln というハードリンクを作成して、実際に `cat`コマンドを用いることで、本当に元ファイルとリンクできているかチェックしたものです。赤線と青線を見比べてみると、リンクカウントが1つ増えていることがわ確認できます。<br></br>

また、黄色線は、作成したハードリンクの内容を表示したものになります。これも無事にリンク元のファイルと同じ文字を出力していることが分かりますね。






![hahahahado.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/255b2eb1-4a55-4ac8-8cc8-518f524d2139.png)

---


`ps`コマンド実行結果：<br></br><br></br>

プロセスとは、** 今まさに動いているプログラムのこと **です。<br></br>
psコマンドは基本的にオプションを付けます。BSD形式とUnix形式の2つがありますが、今回は前者を使っていきます。

| `a` | ユーザーが実行したすべてのプロセスを表示する |
| `f` | 親子関係を表示する |
| `l` | 詳細情報を表示する |
| `x` | 制御端末のない「デーモン」のプロセスの表示 |

それではpsコマンドを実行していきます。以下のスクリーンショットが実行結果になります。表示には、PID, TTY, TIME, CMD とありますが、これは何なのでしょうか。


![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/b81cd9bb-7b97-4500-8ead-a596a9e5e4cc.png)


これらは次のような意味を持っています。
| PID | プロセスID |
| TTY | ターミナル |
| STAT | プロセスの状態 |
| TIME | CPUの稼働時間|
| COMMAND | プロセスの実行内容 |

次は新しいターミナルで、 `tail -f`を実行して、`ps a`コマンドでその結果を見てみました。


![tail.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/8991def4-ab07-478d-8a05-c125534c355c.png)

青線を見ると、ちゃんと `tail -f` が実行されていることが分かります。
また、 ctrl + C でtailコマンドを止めてみたら表示は消えました。<br></br>

次のステップでは、 `ps axf`を実行した結果、プロセスの親子関係をツリー上で表示してみました。


![よるをｋ.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/ef72f42e-3447-4547-8c74-e328cf09f8d5.png)

特に赤線でマークアップしたところがプロセスの親子関係を顕著に表しています。
⚠ `ps axf` コマンドではなくて、 `pstree`　でも同様の結果を得られます。


---

`top`コマンド実行結果：<br></br><br></br>

先ほどのpsコマンドは、そのコマンドを時刻した時点での情報を表示します。しかし、 `top`コマンドではデフォルトで３秒ごとに更新されて表示されます。

スクリーンショットより、赤線より上は、<strong>メモリやCPUについてのシステム情報が表示</strong> （システムリソースの状態）がされています。



青線より下は、 **プロセスの状態**が表示されています。　


![top.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/7f1de562-0d18-4b14-a55a-4de0571e1e45.png)


---


`jobs`コマンド　&　`fg`コマンド　&　`bg` コマンド実行結果：<br></br><br></br>

これらのコマンドを実行する上で、まずは「ジョブ」について理解していなければなりません。ジョブは、<strong>シェルが管理している「実行中のコマンド（プロセス）」</strong>のことです。

ジョブは、「フォアグラウンドジョブ」、「バックグラウンドジョブ」に分かれています。<br></br>

前者は、処理が終わるまでシェルを占有し、処理が終わらないと別のジョブを実行できません。そのため、短期間で終わる作業や出力がすぐ見えるというメリットがあります。<br></br>

後者は、その逆で、シェルを占有せず、っ処理が終わってない場合でも別のジョブを実行できます。

一枚目は、シェルスクリプトを実行してみて、 `jobs` コマンドでその挙動を確認してみました。Runningになっているため、実行中であることが分かります。

二枚目は、先ほどのシェルスクリプトをフォアグランドジョブとバックグランドジョブの両方で実行したものになります。青線部には、赤線部にない「&（アンパサンド）」がついていることが分かります。<br></br>

どちらで実行しているかを `jobs` コマンドで確認したい際、シェルスクリプト名の末尾に「&」がついているとバックグランドで実行しているということになります。


![jobs.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/03e8f2dc-10a7-4904-91b1-0298a97f1004.png)


![fg bg.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/77004a9d-1785-48d4-b193-ed05e1f44bdf.png)


---

`nohup`コマンド実行結果：<br></br><br></br>

1枚目は、`nohup ./sleep.sh &` とコマンドを入力してバックグランドジョブで実行しました。<br></br>

2枚目は、先ほどのコマンドを実行したターミナルを閉じて、30秒まって nohup.out ファイルの内容を表示したものです。これにより、ターミナルを閉じてもちゃんと実行されていたことが分かります。



![スクリーンショット 2025-07-08 105231.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/1d3948a0-92ca-4969-89cc-a62f1de7c015.png)

![スクリーンショット 2025-07-08 105315.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/3fe1fd52-0819-4b5e-9c44-d4c4c15078d3.png)


---

`screen`コマンド実行結果：<br></br><br></br>

1枚目は `screen` コマンドで新しく作ったスクリーンにて、 ./sleep.sh を実行し、 <strong> ctrl + A + D </strong>（元のスクリーンに戻る方法）で元のスクリーンに戻り、 `sccreen -ls` で存在しているスクリーンを表示したものです。黄色い線は、スクリーンID です。

2枚目は、 `screen -r <screenID>` で最初に作った作ったスクリーンに戻ったものです。ちゃんと ./sleep.sh の実行結果が表示されていますね。





![scree.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/d5576d49-ba6d-4f6c-b545-4e2ef566c5dc.png)

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/acc06110-92e3-4d7c-849a-76dc85b4af05.png)

---

`kill`コマンド実行結果：<br></br><br></br>

コマンド説明では、「シグナルを送る」と書きましたが、シグナルとは何でしょうか。<br></br>

シグナルとは、<strong>プロセス、ジョブに対して送る合図の様なもの</strong>
です。

【⇓シグナル集⇓】

| シグナル番号 | シグナル名 | 説明       |
|--------------|------------|------------|
| 1            | HUP        | 再起動      |
| 2            | INT        | 割り込み    |
| 9            | KILL       | 強制終了    |
| 15           | TERM       | 通常終了    |
| 20           | TSTP       | 一時停止    |

このようなものがあります。今回は  `kill` コマンドだけ使用します。<br></br>

1枚目は、現在実行しているプロセスを確認して、重複している cat プロセスを<br></br>

 `kill -s KILL <プロセスID>`を使って削除しました。4つあったプロセスが3つに減っていることが確認できますね。 <br></br>

2枚目は、ジョブを強制終了したものです。<br></br>

`kill -s KILL &<ジョブID>` でその強制終了しました。 実行後、`jobs`コマンドで確認しても何も表示されないので、適切に終了されたことが確認できます。<br></br>

これは自分用に補足するのですが、フォアグラウンドを終了したい際には、 <strong>ctrl + C</strong> で終了できます。


![kill.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/608c2b41-f53a-4929-81ad-dac92288d9a6.png)


![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/4127874/f40164bf-da3a-4e9a-9cd1-c32c9cfbb080.png)










</details>

---

## ✅ まとめ・今後の予定

Linuxを使用したことが一度もなく、慣れない操作の中、AIやほかの方のポートフォリオなどを参考にして新しい概念をたくさん学べました。<br></br>

次回も今回と同様にまだ抑えられていないコマンドをまとめます。
> 🔜 コマンド集3


---
